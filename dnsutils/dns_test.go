package dnsutils

import (
	"errors"
	"fmt"
	"testing"

	"github.com/miekg/dns"
)

const (
	TEST_QNAME = "dnstapcollector.test."
)

func TestRcodeValid(t *testing.T) {
	rcode := RcodeToString(0)
	if rcode != "NOERROR" {
		t.Errorf("rcode noerror expected: %s", rcode)
	}
}

func TestRcodeInvalid(t *testing.T) {
	rcode := RcodeToString(100000)
	if rcode != "UNKNOWN" {
		t.Errorf("invalid rcode - expected: %s", rcode)
	}
}

func TestRdatatypeValid(t *testing.T) {
	rdt := RdatatypeToString(1)
	if rdt != "A" {
		t.Errorf("rdatatype A expected: %s", rdt)
	}
}

func TestRdatatypeInvalid(t *testing.T) {
	rdt := RdatatypeToString(100000)
	if rdt != "UNKNOWN" {
		t.Errorf("rdatatype - expected: %s", rdt)
	}
}

func TestDecodeDns(t *testing.T) {
	dm := new(dns.Msg)
	dm.SetQuestion(TEST_QNAME, dns.TypeA)

	payload, _ := dm.Pack()
	_, err := DecodeDns(payload)
	if err != nil {
		t.Errorf("decode dns error: %s", err)
	}
}

func TestDecodeQuestion(t *testing.T) {
	fqdn := TEST_QNAME

	dm := new(dns.Msg)
	dm.SetQuestion(fqdn, dns.TypeA)
	payload, _ := dm.Pack()

	qname, qtype, offset_rr, _ := DecodeQuestion(1, payload)
	if qname+"." != fqdn {
		t.Errorf("invalid qname: %s", qname)
	}

	if RdatatypeToString(qtype) != "A" {
		t.Errorf("invalid qtype: %d", qtype)
	}
	if offset_rr != len(payload) {
		t.Errorf("invalid offset: %d, payload len: %d", offset_rr, len(payload))
	}
}

func TestDecodeQuestion_Multiple(t *testing.T) {
	paylaod := []byte{
		0x9e, 0x84, 0x01, 0x20, 0x00, 0x03, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		// query 1
		0x01, 0x61, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// query 2
		0x01, 0x62, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// query 3
		0x01, 0x63, 0x00,
		// type AAAA, class IN
		0x00, 0x1c, 0x00, 0x01,
	}

	qname, qtype, offset, err := DecodeQuestion(3, paylaod)
	if err != nil {
		t.Errorf("unexpected error %v", err)
	}
	if qname != "c" || RdatatypeToString(qtype) != "AAAA" {
		t.Errorf("expected qname=C, type=AAAA, got qname=%s, type=%s", qname, RdatatypeToString(qtype))
	}
	if offset != 33 {
		t.Errorf("expected resulting offset to be 33, got %d", offset)
	}
}

func TestDecodeQuestion_Multiple_InvalidCount(t *testing.T) {
	paylaod := []byte{
		0x9e, 0x84, 0x01, 0x20, 0x00, 0x04, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		// query 1
		0x01, 0x61, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// query 2
		0x01, 0x62, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// query 3
		0x01, 0x63, 0x00,
		// type AAAA, class IN
		0x00, 0x1c, 0x00, 0x01,
	}

	_, _, _, err := DecodeQuestion(4, paylaod)
	if !errors.Is(err, ErrDecodeDnsLabelTooShort) {
		t.Errorf("bad error received: %v", err)
	}
}

func TestDecodeAnswer_Ns(t *testing.T) {
	fqdn := TEST_QNAME

	dm := new(dns.Msg)
	dm.SetQuestion(fqdn, dns.TypeA)

	rrNs, _ := dns.NewRR("root-servers.net NS c.root-servers.net")
	rrA, _ := dns.NewRR(fmt.Sprintf("%s A 127.0.0.1", fqdn))

	m := new(dns.Msg)
	m.SetReply(dm)
	m.Authoritative = true
	m.Answer = append(m.Answer, rrA)
	m.Ns = append(m.Ns, rrNs)

	payload, _ := m.Pack()
	_, _, offset_rr, _ := DecodeQuestion(1, payload)
	_, offset_rrns, _ := DecodeAnswer(len(dm.Answer), offset_rr, payload)

	nsAnswers, _, _ := DecodeAnswer(len(m.Ns), offset_rrns, payload)
	if len(nsAnswers) != len(m.Ns) {
		t.Errorf("invalid decode answer, want %d, got: %d", len(m.Ns), len(nsAnswers))
	}
}

func TestDecodeAnswer(t *testing.T) {
	fqdn := TEST_QNAME

	dm := new(dns.Msg)
	dm.SetQuestion(fqdn, dns.TypeA)
	rr1, _ := dns.NewRR(fmt.Sprintf("%s A 127.0.0.1", fqdn))
	rr2, _ := dns.NewRR(fmt.Sprintf("%s A 127.0.0.2", fqdn))
	dm.Answer = append(dm.Answer, rr1)
	dm.Answer = append(dm.Answer, rr2)

	payload, _ := dm.Pack()

	_, _, offset_rr, _ := DecodeQuestion(1, payload)
	answer, _, _ := DecodeAnswer(len(dm.Answer), offset_rr, payload)

	if len(answer) != len(dm.Answer) {
		t.Errorf("invalid decode answer, want %d, got: %d", len(dm.Answer), len(answer))
	}
}

func TestDecodeAnswer_QnameMinimized(t *testing.T) {
	payload := []byte{0x8d, 0xda, 0x81, 0x80, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x05, 0x74,
		0x65, 0x61, 0x6d, 0x73, 0x09, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74,
		0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00, 0x01, 0x00, 0x01, 0xc0, 0x0c, 0x00, 0x05, 0x00,
		0x01, 0x00, 0x00, 0x50, 0xa8, 0x00, 0x0f, 0x05, 0x74, 0x65, 0x61, 0x6d, 0x73, 0x06,
		0x6f, 0x66, 0x66, 0x69, 0x63, 0x65, 0xc0, 0x1c, 0xc0, 0x31, 0x00, 0x05, 0x00, 0x01,
		0x00, 0x00, 0x00, 0x3e, 0x00, 0x26, 0x10, 0x74, 0x65, 0x61, 0x6d, 0x73, 0x2d, 0x6f, 0x66,
		0x66, 0x69, 0x63, 0x65, 0x2d, 0x63, 0x6f, 0x6d, 0x06, 0x73, 0x2d, 0x30, 0x30, 0x30, 0x35,
		0x08, 0x73, 0x2d, 0x6d, 0x73, 0x65, 0x64, 0x67, 0x65, 0x03, 0x6e, 0x65, 0x74, 0x00, 0xc0,
		0x4c, 0x00, 0x05, 0x00, 0x01, 0x00, 0x00, 0x00, 0x7a, 0x00, 0x13, 0x06, 0x73, 0x2d, 0x30,
		0x30, 0x30, 0x35, 0x09, 0x64, 0x63, 0x2d, 0x6d, 0x73, 0x65, 0x64, 0x67, 0x65, 0xc0, 0x6d,
		0xc0, 0x7e, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x09, 0x00, 0x04, 0x34, 0x71, 0xc3,
		0x84, 0x00, 0x00, 0x29, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}

	_, _, offset_rr, _ := DecodeQuestion(1, payload)
	_, _, err := DecodeAnswer(4, offset_rr, payload)
	if err != nil {
		t.Errorf("failed to decode valid dns packet with minimization")
	}
}

func TestDecodeRdataA(t *testing.T) {
	fqdn := TEST_QNAME

	dm := new(dns.Msg)
	dm.SetQuestion(fqdn, dns.TypeA)

	rdata := "127.0.0.1"
	rr1, _ := dns.NewRR(fmt.Sprintf("%s A %s", fqdn, rdata))
	dm.Answer = append(dm.Answer, rr1)

	payload, _ := dm.Pack()

	_, _, offset_rr, _ := DecodeQuestion(1, payload)
	answer, _, _ := DecodeAnswer(len(dm.Answer), offset_rr, payload)

	if answer[0].Rdata != rdata {
		t.Errorf("invalid decode for rdata A, want %s, got: %s", rdata, answer[0].Rdata)
	}
}

func TestDecodeRdataA_Short(t *testing.T) {
	payload := []byte{
		0x43, 0xac, 0x01, 0x00, 0x00, 0x01, 0x00, 0x01,
		0x00, 0x00, 0x00, 0x00,
		// Query section
		0x0f, 0x64, 0x6e, 0x73,
		0x74, 0x61, 0x70, 0x63, 0x6f, 0x6c, 0x6c, 0x65,
		0x63, 0x74, 0x6f, 0x72, 0x04, 0x74, 0x65, 0x73,
		0x74, 0x00, 0x00, 0x01, 0x00, 0x01,
		// Answer Resource Record
		0x0f, 0x64,
		0x6e, 0x73, 0x74, 0x61, 0x70, 0x63, 0x6f, 0x6c,
		0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x04, 0x74,
		0x65, 0x73, 0x74, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x0e, 0x10,
		// RDLENGTH
		0x00, 0x03,
		// RDATA (1 byte too short for A record)
		0x7f, 0x00, 0x00,
	}
	_, _, offsetrr, err := DecodeQuestion(1, payload)
	if err != nil {
		t.Errorf("Unexpected error decoding question: %v", err)
	}

	_, _, erra := DecodeAnswer(1, offsetrr, payload)
	if !errors.Is(erra, ErrDecodeDnsAnswerRdataTooShort) {
		t.Errorf("bad error returned: %v", erra)
	}
}

func TestDecodeRdataAAAA(t *testing.T) {
	fqdn := TEST_QNAME

	dm := new(dns.Msg)
	dm.SetQuestion(fqdn, dns.TypeA)

	rdata := "fe8::2"
	rr1, _ := dns.NewRR(fmt.Sprintf("%s AAAA %s", fqdn, rdata))
	dm.Answer = append(dm.Answer, rr1)

	payload, _ := dm.Pack()

	_, _, offset_rr, _ := DecodeQuestion(1, payload)
	answer, _, _ := DecodeAnswer(len(dm.Answer), offset_rr, payload)

	if answer[0].Rdata != rdata {
		t.Errorf("invalid decode for rdata AAAA, want %s, got: %s", rdata, answer[0].Rdata)
	}
}
func TestDecodeRdataAAAA_Short(t *testing.T) {
	payload := []byte{
		// header
		0x3b, 0x33, 0x01, 0x00, 0x00, 0x01, 0x00, 0x01,
		0x00, 0x00, 0x00, 0x00,
		// Query section
		0x0f, 0x64, 0x6e, 0x73,
		0x74, 0x61, 0x70, 0x63, 0x6f, 0x6c, 0x6c, 0x65,
		0x63, 0x74, 0x6f, 0x72, 0x04, 0x74, 0x65, 0x73,
		0x74, 0x00, 0x00, 0x01, 0x00, 0x01,
		// Answer resource record
		0x0f, 0x64,
		0x6e, 0x73, 0x74, 0x61, 0x70, 0x63, 0x6f, 0x6c,
		0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x04, 0x74,
		0x65, 0x73, 0x74, 0x00,
		// type AAAA, class IN
		0x00, 0x1c, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x0e, 0x10,
		// RDLENGTH
		0x00, 0x0c,
		// RDATA
		0xfe, 0x80,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00,
	}

	_, _, offsetset_rr, err := DecodeQuestion(1, payload)
	if err != nil {
		t.Errorf("unexpected error while decoding question: %v", err)
	}
	_, _, erra := DecodeAnswer(1, offsetset_rr, payload)
	if !errors.Is(erra, ErrDecodeDnsAnswerRdataTooShort) {
		t.Errorf("bad error returned: %v", erra)
	}
}

func TestDecodeRdataCNAME(t *testing.T) {
	fqdn := TEST_QNAME

	dm := new(dns.Msg)
	dm.SetQuestion(fqdn, dns.TypeA)

	rdata := "test.collector.org"
	rr1, _ := dns.NewRR(fmt.Sprintf("%s CNAME %s", fqdn, rdata))
	dm.Answer = append(dm.Answer, rr1)

	payload, _ := dm.Pack()

	_, _, offset_rr, _ := DecodeQuestion(1, payload)
	answer, _, _ := DecodeAnswer(len(dm.Answer), offset_rr, payload)

	if answer[0].Rdata != rdata {
		t.Errorf("invalid decode for rdata CNAME, want %s, got: %s", rdata, answer[0].Rdata)
	}
}

func TestDecodeRdataMX(t *testing.T) {
	fqdn := TEST_QNAME

	dm := new(dns.Msg)
	dm.SetQuestion(fqdn, dns.TypeA)

	rdata := "5 gmail-smtp-in.l.google.com"
	rr1, _ := dns.NewRR(fmt.Sprintf("%s MX %s", fqdn, rdata))
	dm.Answer = append(dm.Answer, rr1)

	payload, _ := dm.Pack()

	_, _, offset_rr, _ := DecodeQuestion(1, payload)
	answer, _, _ := DecodeAnswer(len(dm.Answer), offset_rr, payload)

	if answer[0].Rdata != rdata {
		t.Errorf("invalid decode for rdata MX, want %s, got: %s", rdata, answer[0].Rdata)
	}
}

func TestDecodeRdataMX_Short(t *testing.T) {
	payload := []byte{
		// header
		0xed, 0x7f, 0x01, 0x00, 0x00, 0x01, 0x00, 0x01,
		0x00, 0x00, 0x00, 0x00,
		// Question seection
		0x0f, 0x64, 0x6e, 0x73,
		0x74, 0x61, 0x70, 0x63, 0x6f, 0x6c, 0x6c, 0x65,
		0x63, 0x74, 0x6f, 0x72, 0x04, 0x74, 0x65, 0x73,
		0x74, 0x00, 0x00, 0x01, 0x00, 0x01,
		// Answer Resource Record
		0x0f, 0x64,
		0x6e, 0x73, 0x74, 0x61, 0x70, 0x63, 0x6f, 0x6c,
		0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x04, 0x74,
		0x65, 0x73, 0x74, 0x00,
		// type MX, class IN
		0x00, 0x0f, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x0e, 0x10,
		// RDLENGTH
		0x00, 0x01,
		// RDATA
		0x00,
	}
	_, _, offset_rr, err := DecodeQuestion(1, payload)
	if err != nil {
		t.Errorf("unexpected error while decoding question: %v", err)
	}
	_, _, erra := DecodeAnswer(1, offset_rr, payload)
	if !errors.Is(erra, ErrDecodeDnsAnswerRdataTooShort) {
		t.Errorf("bad error returned: %v", erra)
	}

}

func TestDecodeRdataMX_Minimal(t *testing.T) {
	payload := []byte{
		// header
		0xed, 0x7f, 0x01, 0x00, 0x00, 0x01, 0x00, 0x01,
		0x00, 0x00, 0x00, 0x00,
		// Question seection
		0x0f, 0x64, 0x6e, 0x73,
		0x74, 0x61, 0x70, 0x63, 0x6f, 0x6c, 0x6c, 0x65,
		0x63, 0x74, 0x6f, 0x72, 0x04, 0x74, 0x65, 0x73,
		0x74, 0x00, 0x00, 0x01, 0x00, 0x01,
		// Answer Resource Record
		0x0f, 0x64,
		0x6e, 0x73, 0x74, 0x61, 0x70, 0x63, 0x6f, 0x6c,
		0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x04, 0x74,
		0x65, 0x73, 0x74, 0x00,
		// type MX, class IN
		0x00, 0x0f, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x0e, 0x10,
		// RDLENGTH
		0x00, 0x03,
		// RDATA
		0x00, 0x00, 0x00,
	}
	_, _, offset_rr, err := DecodeQuestion(1, payload)
	if err != nil {
		t.Errorf("unexpected error while decoding question: %v", err)
	}
	answer, _, erra := DecodeAnswer(1, offset_rr, payload)
	if erra != nil {
		t.Errorf("unexpected error while decoding answer: %v", err)
	}
	expected := "0 "
	if answer[0].Rdata != expected {
		t.Errorf("invalid decode for MX rdata, expected %s got %s", expected, answer[0].Rdata)
	}
}

func TestDecodeRdataSRV(t *testing.T) {
	fqdn := TEST_QNAME

	dm := new(dns.Msg)
	dm.SetQuestion(fqdn, dns.TypeA)

	rdata := "20 0 5222 alt2.xmpp.l.google.com"
	rr1, _ := dns.NewRR(fmt.Sprintf("%s SRV %s", fqdn, rdata))
	dm.Answer = append(dm.Answer, rr1)

	payload, _ := dm.Pack()

	_, _, offset_rr, _ := DecodeQuestion(1, payload)
	answer, _, _ := DecodeAnswer(len(dm.Answer), offset_rr, payload)

	if answer[0].Rdata != rdata {
		t.Errorf("invalid decode for rdata SRV, want %s, got: %s", rdata, answer[0].Rdata)
	}
}

func TestDecodeRdataSRV_Short(t *testing.T) {
	payload := []byte{
		// header
		0xd9, 0x93, 0x01, 0x00, 0x00, 0x01, 0x00, 0x01,
		0x00, 0x00, 0x00, 0x00,
		// Question section
		0x0f, 0x64, 0x6e, 0x73,
		0x74, 0x61, 0x70, 0x63, 0x6f, 0x6c, 0x6c, 0x65,
		0x63, 0x74, 0x6f, 0x72, 0x04, 0x74, 0x65, 0x73,
		0x74, 0x00, 0x00, 0x01, 0x00, 0x01,
		// Answer section
		0x0f, 0x64,
		0x6e, 0x73, 0x74, 0x61, 0x70, 0x63, 0x6f, 0x6c,
		0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x04, 0x74,
		0x65, 0x73, 0x74, 0x00,
		// type SRV, class IN
		0x00, 0x21, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x0e, 0x10,
		// RDLENGTH
		0x00, 0x04,
		// RDATA
		// priority
		0x00, 0x14,
		// weight
		0x00, 0x00,
		// missing port and target
	}

	_, _, offset_rr, err := DecodeQuestion(1, payload)
	if err != nil {
		t.Errorf("unexpected error while decoding question: %v", err)
	}
	_, _, erra := DecodeAnswer(1, offset_rr, payload)
	if !errors.Is(erra, ErrDecodeDnsAnswerRdataTooShort) {
		t.Errorf("bad error returned: %v", erra)
	}
}

func TestDecodeRdataSRV_Minimal(t *testing.T) {
	payload := []byte{
		// header
		0xd9, 0x93, 0x01, 0x00, 0x00, 0x01, 0x00, 0x01,
		0x00, 0x00, 0x00, 0x00,
		// Question section
		0x0f, 0x64, 0x6e, 0x73,
		0x74, 0x61, 0x70, 0x63, 0x6f, 0x6c, 0x6c, 0x65,
		0x63, 0x74, 0x6f, 0x72, 0x04, 0x74, 0x65, 0x73,
		0x74, 0x00, 0x00, 0x01, 0x00, 0x01,
		// Answer section
		0x0f, 0x64,
		0x6e, 0x73, 0x74, 0x61, 0x70, 0x63, 0x6f, 0x6c,
		0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x04, 0x74,
		0x65, 0x73, 0x74, 0x00,
		// type SRV, class IN
		0x00, 0x21, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x0e, 0x10,
		// RDLENGTH
		0x00, 0x07,
		// RDATA
		// priority
		0x00, 0x14,
		// weight
		0x00, 0x00,
		// port
		0x00, 0x10,
		// empty target
		0x00,
	}

	_, _, offset_rr, err := DecodeQuestion(1, payload)
	if err != nil {
		t.Errorf("unexpected error while decoding question: %v", err)
	}
	answer, _, erra := DecodeAnswer(1, offset_rr, payload)
	if erra != nil {
		t.Errorf("unexpected error while decoding answer: %v", err)
	}
	expected_rdata := "20 0 16 "
	if answer[0].Rdata != expected_rdata {
		t.Errorf("invalid decode for rdata SRV, want %s, got: %s", expected_rdata, answer[0].Rdata)
	}
}
func TestDecodeRdataNS(t *testing.T) {
	fqdn := TEST_QNAME

	dm := new(dns.Msg)
	dm.SetQuestion(fqdn, dns.TypeA)

	rdata := "ns1.dnscollector"
	rr1, _ := dns.NewRR(fmt.Sprintf("%s NS %s", fqdn, rdata))
	dm.Answer = append(dm.Answer, rr1)

	payload, _ := dm.Pack()

	_, _, offset_rr, _ := DecodeQuestion(1, payload)
	answer, _, _ := DecodeAnswer(len(dm.Answer), offset_rr, payload)

	if answer[0].Rdata != rdata {
		t.Errorf("invalid decode for rdata NS, want %s, got: %s", rdata, answer[0].Rdata)
	}
}

func TestDecodeRdataTXT(t *testing.T) {
	fqdn := TEST_QNAME

	dm := new(dns.Msg)
	dm.SetQuestion(fqdn, dns.TypeA)

	rdata := "hello world"
	rr1, _ := dns.NewRR(fmt.Sprintf("%s TXT \"%s\"", fqdn, rdata))
	dm.Answer = append(dm.Answer, rr1)

	payload, _ := dm.Pack()

	_, _, offset_rr, _ := DecodeQuestion(1, payload)
	answer, _, _ := DecodeAnswer(len(dm.Answer), offset_rr, payload)

	if answer[0].Rdata != rdata {
		t.Errorf("invalid decode for rdata TXT, want %s, got: %s", rdata, answer[0].Rdata)
	}
}

func TestDecodeRdataTXT_Empty(t *testing.T) {
	payload := []byte{
		// header
		0x86, 0x08, 0x01, 0x00, 0x00, 0x01, 0x00, 0x01,
		0x00, 0x00, 0x00, 0x00,
		// question section
		0x0f, 0x64, 0x6e, 0x73,
		0x74, 0x61, 0x70, 0x63, 0x6f, 0x6c, 0x6c, 0x65,
		0x63, 0x74, 0x6f, 0x72, 0x04, 0x74, 0x65, 0x73,
		0x74, 0x00, 0x00, 0x01, 0x00, 0x01,
		// answer section
		0x0f, 0x64,
		0x6e, 0x73, 0x74, 0x61, 0x70, 0x63, 0x6f, 0x6c,
		0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x04, 0x74,
		0x65, 0x73, 0x74, 0x00,
		// type TXT, class IN
		0x00, 0x10, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x0e, 0x10,
		// RDLENGTH
		0x00, 0x00,
		// no data
	}

	_, _, offset_rr, err := DecodeQuestion(1, payload)
	if err != nil {
		t.Errorf("unexpected error while decoding question: %v", err)
	}
	_, _, erra := DecodeAnswer(1, offset_rr, payload)
	if !errors.Is(erra, ErrDecodeDnsAnswerRdataTooShort) {
		t.Errorf("bad error returned: %v", erra)
	}

}
func TestDecodeRdataTXT_Short(t *testing.T) {
	payload := []byte{
		// header
		0x86, 0x08, 0x01, 0x00, 0x00, 0x01, 0x00, 0x01,
		0x00, 0x00, 0x00, 0x00,
		// question section
		0x0f, 0x64, 0x6e, 0x73,
		0x74, 0x61, 0x70, 0x63, 0x6f, 0x6c, 0x6c, 0x65,
		0x63, 0x74, 0x6f, 0x72, 0x04, 0x74, 0x65, 0x73,
		0x74, 0x00, 0x00, 0x01, 0x00, 0x01,
		// answer section
		0x0f, 0x64,
		0x6e, 0x73, 0x74, 0x61, 0x70, 0x63, 0x6f, 0x6c,
		0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x04, 0x74,
		0x65, 0x73, 0x74, 0x00,
		// type TXT, class IN
		0x00, 0x10, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x0e, 0x10,
		// RDLENGTH
		0x00, 0x0a,
		//  RDATA
		// length
		0x0b,
		// characters
		0x68,
		0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x77, 0x6f, 0x72,
		// missing two bytes
	}

	_, _, offset_rr, err := DecodeQuestion(1, payload)
	if err != nil {
		t.Errorf("unexpected error while decoding question: %v", err)
	}
	_, _, erra := DecodeAnswer(1, offset_rr, payload)
	if !errors.Is(erra, ErrDecodeDnsAnswerRdataTooShort) {
		t.Errorf("bad error returned: %v", erra)
	}

}
func TestDecodeRdataTXT_NoTxt(t *testing.T) {
	payload := []byte{
		// header
		0x86, 0x08, 0x01, 0x00, 0x00, 0x01, 0x00, 0x01,
		0x00, 0x00, 0x00, 0x00,
		// question section
		0x0f, 0x64, 0x6e, 0x73,
		0x74, 0x61, 0x70, 0x63, 0x6f, 0x6c, 0x6c, 0x65,
		0x63, 0x74, 0x6f, 0x72, 0x04, 0x74, 0x65, 0x73,
		0x74, 0x00, 0x00, 0x01, 0x00, 0x01,
		// answer section
		0x0f, 0x64,
		0x6e, 0x73, 0x74, 0x61, 0x70, 0x63, 0x6f, 0x6c,
		0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x04, 0x74,
		0x65, 0x73, 0x74, 0x00,
		// type TXT, class IN
		0x00, 0x10, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x0e, 0x10,
		// RDLENGTH
		0x00, 0x01,
		//  RDATA
		// length
		0x00,
		// no txt-data
	}

	_, _, offset_rr, err := DecodeQuestion(1, payload)
	if err != nil {
		t.Errorf("unexpected error while decoding question: %v", err)
	}
	answer, _, erra := DecodeAnswer(1, offset_rr, payload)
	if erra != nil {
		t.Errorf("unexpected error while decoding answer: %v", err)
	}

	if answer[0].Rdata != "" {
		t.Errorf("expected empty string in RDATA, got: %s", answer[0].Rdata)
	}

}

func TestDecodeRdataPTR(t *testing.T) {
	fqdn := TEST_QNAME

	dm := new(dns.Msg)
	dm.SetQuestion(fqdn, dns.TypeA)

	rdata := "one.one.one.one"
	rr1, _ := dns.NewRR(fmt.Sprintf("%s PTR %s", fqdn, rdata))
	dm.Answer = append(dm.Answer, rr1)

	payload, _ := dm.Pack()

	_, _, offset_rr, _ := DecodeQuestion(1, payload)
	answer, _, _ := DecodeAnswer(len(dm.Answer), offset_rr, payload)

	if answer[0].Rdata != rdata {
		t.Errorf("invalid decode for rdata PTR, want %s, got: %s", rdata, answer[0].Rdata)
	}
}

func TestDecodeRdataSOA(t *testing.T) {
	fqdn := TEST_QNAME

	dm := new(dns.Msg)
	dm.SetQuestion(fqdn, dns.TypeA)

	rdata := "ns1.google.com dns-admin.google.com 412412655 900 900 1800 60"
	rr1, _ := dns.NewRR(fmt.Sprintf("%s SOA %s", fqdn, rdata))
	dm.Answer = append(dm.Answer, rr1)

	payload, _ := dm.Pack()

	_, _, offset_rr, _ := DecodeQuestion(1, payload)
	answer, _, _ := DecodeAnswer(len(dm.Answer), offset_rr, payload)

	if answer[0].Rdata != rdata {
		t.Errorf("invalid decode for rdata SOA, want %s, got: %s", rdata, answer[0].Rdata)
	}
}

func TestDecodeRdataSOA_Short(t *testing.T) {
	payload := []byte{
		// header
		0x28, 0xba, 0x01, 0x00, 0x00, 0x01, 0x00, 0x01,
		0x00, 0x00, 0x00, 0x00,
		// Query section
		0x0f, 0x64, 0x6e, 0x73,
		0x74, 0x61, 0x70, 0x63, 0x6f, 0x6c, 0x6c, 0x65,
		0x63, 0x74, 0x6f, 0x72, 0x04, 0x74, 0x65, 0x73,
		0x74, 0x00, 0x00, 0x01, 0x00, 0x01,
		// Answer Resource Record,
		0x0f, 0x64,
		0x6e, 0x73, 0x74, 0x61, 0x70, 0x63, 0x6f, 0x6c,
		0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x04, 0x74,
		0x65, 0x73, 0x74, 0x00,
		// type SOA, class IN
		0x00, 0x06, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x0e, 0x10,
		// RDLENGTH 54
		0x00, 0x36,
		// RDATA
		// MNAME
		0x03, 0x6e,
		0x73, 0x31, 0x06, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
		0x65, 0x03, 0x63, 0x6f, 0x6d, 0x00,
		// RNAME
		0x09, 0x64,
		0x6e, 0x73, 0x2d, 0x61, 0x64, 0x6d, 0x69, 0x6e,
		0x06, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x03,
		0x63, 0x6f, 0x6d, 0x00,
		// serial
		0x18, 0x94, 0xea, 0xef,
		// refresh
		0x00, 0x00, 0x03, 0x84,
		// retry
		0x00, 0x00, 0x03, 0x84,
		// expire
		0x00, 0x00, 0x07, 0x08,
		// minimum -field missing from the RDATA
	}

	_, _, offsset_rr, err := DecodeQuestion(1, payload)
	if err != nil {
		t.Errorf("Unable to decode question: %v", err)
	}
	_, _, erra := DecodeAnswer(1, offsset_rr, payload)
	if !errors.Is(erra, ErrDecodeDnsAnswerRdataTooShort) {
		t.Errorf("bad error returned: %v", erra)
	}
}

func TestDecodeRdataSOA_Minimization(t *testing.T) {
	// loop between qnames
	payload := []byte{164, 66, 129, 128, 0, 1, 0, 0, 0, 1, 0, 0, 8, 102, 114, 101, 115, 104, 114, 115, 115, 4, 109,
		99, 104, 100, 2, 109, 101, 0, 0, 28, 0, 1, 192, 21, 0, 6, 0, 1, 0, 0, 0, 60, 0, 43, 6, 100, 110, 115, 49, 48,
		51, 3, 111, 118, 104, 3, 110, 101, 116, 0, 4, 116, 101, 99, 104, 192, 53,
		120, 119, 219, 34, 0, 1, 81, 128, 0, 0, 14, 16, 0, 54, 238, 128, 0, 0, 0, 60}

	_, _, offset_rr, _ := DecodeQuestion(1, payload)
	_, _, err := DecodeAnswer(1, offset_rr, payload)
	if err != nil {
		t.Errorf(" error returned: %v", err)
	}
}
func TestDecodeQuestion_SkipOpt(t *testing.T) {
	payload := []byte{
		0x43, 0xac, 0x01, 0x00, 0x00, 0x01, 0x00, 0x02,
		0x00, 0x00, 0x00, 0x00,
		// Query section
		0x0f, 0x64, 0x6e, 0x73,
		0x74, 0x61, 0x70, 0x63, 0x6f, 0x6c, 0x6c, 0x65,
		0x63, 0x74, 0x6f, 0x72, 0x04, 0x74, 0x65, 0x73,
		0x74, 0x00, 0x00, 0x01, 0x00, 0x01,
		// Answer Resource Records
		0x0f, 0x64,
		0x6e, 0x73, 0x74, 0x61, 0x70, 0x63, 0x6f, 0x6c,
		0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x04, 0x74,
		0x65, 0x73, 0x74, 0x00,
		// type OPT, class IN
		0x00, 0x29, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x0e, 0x10,
		// RDLENGTH
		0x00, 0x01,
		//RDATA
		0x01,
		// 2nd resource record
		0x0f, 0x64,
		0x6e, 0x73, 0x74, 0x61, 0x70, 0x63, 0x6f, 0x6c,
		0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x04, 0x74,
		0x65, 0x73, 0x74, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x0e, 0x10,
		// RDLENGTH
		0x00, 0x04,
		// RDATA
		0x7f, 0x00, 0x00, 0x01,
	}
	_, _, offsetrr, err := DecodeQuestion(1, payload)
	if err != nil {
		t.Errorf("Unexpected error decoding question: %v", err)
	}

	answer, _, erra := DecodeAnswer(2, offsetrr, payload)
	if erra != nil {
		t.Errorf("Unexpected error decoding answer: %v", erra)
	}
	if len(answer) != 1 {
		t.Fatalf("Expected answer to contain one resource record, got %d", len(answer))
	}
	if answer[0].Rdatatype != RdatatypeToString(0x01) || answer[0].Rdata != "127.0.0.1" {
		t.Errorf("unexpected answer %s %s, expected A 127.0.0.1", answer[0].Rdatatype, answer[0].Rdata)
	}
}

func TestDecodeDns_HeaderTooShort(t *testing.T) {
	decoded := []byte{183, 59}
	_, err := DecodeDns(decoded)
	if !errors.Is(err, ErrDecodeDnsHeaderTooShort) {
		t.Errorf("bad error returned: %v", err)
	}
}

func TestDecodeDnsQuestion_InvalidOffset(t *testing.T) {
	decoded := []byte{183, 59, 130, 217, 128, 16, 0, 51, 165, 67, 0, 0}
	_, _, _, err := DecodeQuestion(1, decoded)
	if !errors.Is(err, ErrDecodeDnsLabelTooShort) {
		t.Errorf("bad error returned: %v", err)
	}
}

func TestDecodeDnsQuestion_PacketTooShort(t *testing.T) {
	decoded := []byte{183, 59, 130, 217, 128, 16, 0, 51, 165, 67, 0, 0, 1, 1, 8, 10, 23}
	_, _, _, err := DecodeQuestion(1, decoded)
	if !errors.Is(err, ErrDecodeDnsLabelTooShort) {
		t.Errorf("bad error returned: %v", err)
	}
}

func TestDecodeDnsQuestion_QtypeMissing(t *testing.T) {
	decoded := []byte{88, 27, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 15, 100, 110, 115, 116, 97, 112,
		99, 111, 108, 108, 101, 99, 116, 111, 114, 4, 116, 101, 115, 116, 0}
	_, _, _, err := DecodeQuestion(1, decoded)
	if !errors.Is(err, ErrDecodeQuestionQtypeTooShort) {
		t.Errorf("bad error returned: %v", err)
	}
}

func TestDecodeQuestion_InvalidPointer(t *testing.T) {
	decoded := []byte{88, 27, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 202}
	_, _, _, err := DecodeQuestion(1, decoded)
	if !errors.Is(err, ErrDecodeDnsLabelTooShort) {
		t.Errorf("bad error returned: %v", err)
	}
}

func TestDecodeDnsAnswer_PacketTooShort(t *testing.T) {
	payload := []byte{46, 172, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 15, 100, 110, 115, 116, 97, 112, 99, 111, 108, 108, 101, 99, 116,
		111, 114, 4, 116, 101, 115, 116, 0, 0, 1, 0, 1, 15, 100, 110, 115, 116, 97, 112, 99, 111, 108, 108, 101, 99, 116,
		111, 114, 4, 116, 101, 115, 116, 0, 0, 1, 0, 1, 0, 0, 14, 16, 0}

	_, _, offset_rr, _ := DecodeQuestion(1, payload)
	_, _, err := DecodeAnswer(1, offset_rr, payload)
	if !errors.Is(err, ErrDecodeDnsAnswerTooShort) {
		t.Errorf("bad error returned: %v", err)
	}
}

func TestDecodeDnsAnswer_PathologicalPacket(t *testing.T) {
	// Create a message with one question and `n` answers (`n` determined later).
	decoded := make([]byte, 65500)
	copy(decoded, []byte{88, 27, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0})

	// Create a rather suboptimal name for the question.
	// The answers point to this a bajillion times later.
	// This name breaks several rules:v
	//  * Label length is > 63
	//  * Name length is > 255 bytes
	//  * Pointers jump all over the place, not just backwards
	i := 12
	for {
		// Create a bunch of interleaved labels of length 191,
		// each label immediately followed by a pointer to the
		// label next to it. The last label of the interleaved chunk
		// is followed with a pointer to forwards to the next chunk
		// of interleaved labels:
		//
		// [191 ... 191 ... 191 ... ... ptr1 ptr2 ... ptrN 191 ... 191 ...]
		//           ^      ^            │    │        │    ^
		//           │      └────────────┼────┘        └────┘
		//           └───────────────────┘
		//
		// We then repeat this pattern as many times as we can within the
		// first 16383 bytes (so that we can point to it later).
		// Then cleanly closing the name with a null byte in the end allows us to
		// create a name of around 700 kilobytes (I checked once, don't quote me on this).
		if 16384-i < 384 {
			decoded[i] = 0
			break
		}
		for j := 0; j < 192; j += 2 {
			decoded[i] = 191
			i += 2
		}
		for j := 0; j < 190; j += 2 {
			offset := i - 192 + 2
			decoded[i] = 0xc0 | byte(offset>>8)
			decoded[i+1] = byte(offset & 0xff)
			i += 2
		}
		offset := i + 2
		decoded[i] = 0xc0 | byte(offset>>8)
		decoded[i+1] = byte(offset & 0xff)
		i += 2
	}

	// Fill in the rest of the question
	copy(decoded[i:], []byte{0, 5, 0, 1})
	i += 4

	// Fit as many answers as we can that contain CNAME RDATA pointing to
	// the bloated name created above.
	ancount := 0
	for j := i; j+13 <= len(decoded); j += 13 {
		copy(decoded[j:], []byte{0, 0, 5, 0, 0, 0, 0, 0, 1, 0, 2, 192, 12})
		ancount += 1
	}

	// Update the message with the answer count
	decoded[6] = byte(ancount >> 8)
	decoded[7] = byte(ancount & 0xff)

	_, _, err := DecodeAnswer(ancount, i, decoded)
	if !errors.Is(err, ErrDecodeDnsLabelInvalidData) {
		t.Errorf("bad error returned: %v", err)
	}
}

func TestDecodeDnsAnswer_RdataTooShort(t *testing.T) {
	payload := []byte{46, 172, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 15, 100, 110, 115, 116, 97, 112, 99, 111, 108, 108, 101, 99, 116,
		111, 114, 4, 116, 101, 115, 116, 0, 0, 1, 0, 1, 15, 100, 110, 115, 116, 97, 112, 99, 111, 108, 108, 101, 99, 116,
		111, 114, 4, 116, 101, 115, 116, 0, 0, 1, 0, 1, 0, 0, 14, 16, 0, 4, 127, 0}

	_, _, offset_rr, _ := DecodeQuestion(1, payload)
	_, _, err := DecodeAnswer(1, offset_rr, payload)
	if !errors.Is(err, ErrDecodeDnsAnswerRdataTooShort) {
		t.Errorf("bad error returned: %v", err)
	}
}

func TestDecodeDnsAnswer_InvalidPtr(t *testing.T) {
	payload := []byte{128, 177, 129, 160, 0, 1, 0, 1, 0, 0, 0, 1, 5, 104, 101, 108, 108, 111, 4,
		109, 99, 104, 100, 2, 109, 101, 0, 0, 1, 0, 1, 192, 254, 0, 1, 0, 1, 0, 0,
		14, 16, 0, 4, 83, 112, 146, 176}

	_, _, offset_rr, _ := DecodeQuestion(1, payload)
	_, _, err := DecodeAnswer(1, offset_rr, payload)
	if !errors.Is(err, ErrDecodeDnsLabelInvalidPointer) {
		t.Errorf("bad error returned: %v", err)
	}
}

func TestDecodeDnsAnswer_InvalidPtr_Loop1(t *testing.T) {
	// loop qname on himself
	payload := []byte{128, 177, 129, 160, 0, 1, 0, 1, 0, 0, 0, 1, 5, 104, 101, 108, 108, 111, 4,
		109, 99, 104, 100, 2, 109, 101, 0, 0, 1, 0, 1, 192, 31, 0, 1, 0, 1, 0, 0,
		14, 16, 0, 4, 83, 112, 146, 176}

	_, _, offset_rr, _ := DecodeQuestion(1, payload)
	_, _, err := DecodeAnswer(1, offset_rr, payload)
	if !errors.Is(err, ErrDecodeDnsLabelInvalidPointer) {
		t.Errorf("bad error returned: %v", err)
	}
}

func TestDecodeDnsAnswer_InvalidPtr_Loop2(t *testing.T) {
	// loop between qnames
	payload := []byte{128, 177, 129, 160, 0, 1, 0, 2, 0, 0, 0, 1, 5, 104, 101, 108, 108, 111, 4,
		109, 99, 104, 100, 2, 109, 101, 0, 0, 1, 0, 1, 192, 47, 0, 1, 0, 1, 0, 0,
		14, 16, 0, 4, 83, 112, 146, 176, 192, 31, 0, 1, 0, 1, 0, 0,
		14, 16, 0, 4, 83, 112, 146, 176}

	_, _, offset_rr, _ := DecodeQuestion(1, payload)
	_, _, err := DecodeAnswer(1, offset_rr, payload)
	if !errors.Is(err, ErrDecodeDnsLabelInvalidPointer) {
		t.Errorf("bad error returned: %v", err)
	}
}

func TestDecodeDnsLabel_InvalidOffset_NegativeOffset(t *testing.T) {
	payload := []byte{0x01, 0x61, 0x00}

	_, _, err := ParseLabels(-1, payload)
	if !errors.Is(err, ErrDecodeDnsLabelInvalidOffset) {
		t.Errorf("bad error returned: %v", err)
	}
}

func TestDecodeDnsLabel_InvalidOffset_StartOutOfBounds(t *testing.T) {
	payload := []byte{0x01, 0x61, 0x00}

	_, _, err := ParseLabels(4, payload)
	if !errors.Is(err, ErrDecodeDnsLabelTooShort) {
		t.Errorf("bad error returned: %v", err)
	}
}

func TestDecodeDnsLabel_InvalidOffset_RunOutOfBounds(t *testing.T) {
	payload := []byte{0x01, 0x61}

	_, _, err := ParseLabels(0, payload)
	if !errors.Is(err, ErrDecodeDnsLabelTooShort) {
		t.Errorf("bad error returned: %v", err)
	}
}

func TestDecodeDnsLabel_InvalidOffset_PointerByteOutOfBounds(t *testing.T) {
	payload := []byte{0x01, 0x61, 0xc0}

	_, _, err := ParseLabels(0, payload)
	if !errors.Is(err, ErrDecodeDnsLabelTooShort) {
		t.Errorf("bad error returned: %v", err)
	}
}

func TestDecodeDnsLabel_LabelTooShort(t *testing.T) {
	payload := []byte{0x01}

	_, _, err := ParseLabels(0, payload)
	if !errors.Is(err, ErrDecodeDnsLabelTooShort) {
		t.Errorf("bad error returned: %v", err)
	}
}

func TestDecodeDnsLabel_NoExtraDotAfterPtr(t *testing.T) {
	payload := []byte{0x00, 0x01, 0x61, 0xc0, 0x00}

	label, _, _ := ParseLabels(1, payload)
	if label != "a" {
		t.Errorf("bad label parsed: %v", label)
	}
}

func TestDecodeDnsLabel_InvalidLabelLengthByte1(t *testing.T) {
	payload := []byte{0x40}

	_, _, err := ParseLabels(0, payload)
	if !errors.Is(err, ErrDecodeDnsLabelInvalidData) {
		t.Errorf("bad error returned: %v", err)
	}
}

func TestDecodeDnsLabel_InvalidLabelLengthByte2(t *testing.T) {
	payload := []byte{0x80}

	_, _, err := ParseLabels(0, payload)
	if !errors.Is(err, ErrDecodeDnsLabelInvalidData) {
		t.Errorf("bad error returned: %v", err)
	}
}

func TestDecodeDnsLabel_ValidTotalLength(t *testing.T) {
	// A 253-character label
	payload := []byte{
		0x3f, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x3f, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x3f, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x3d, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x00,
	}
	valid := "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"

	label, _, _ := ParseLabels(0, payload)
	if label != valid {
		t.Errorf("bad name parsed: %v", label)
	}
}

func TestDecodeDnsLabel_InvalidTotalLength_WithoutPtr(t *testing.T) {
	// A 254-character label (including separator dots)
	payload := []byte{
		0x3f, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x3f, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x3f, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x3e, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x00,
	}
	_, _, err := ParseLabels(0, payload)
	if !errors.Is(err, ErrDecodeDnsLabelTooLong) {
		t.Errorf("bad error returned: %v", err)
	}
}

func TestDecodeDnsLabel_InvalidTotalLength_WithPtr(t *testing.T) {
	// A 254-character label (including separator dots), containing a pointer
	payload := []byte{
		0x3f, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x3f, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x3f, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x3c, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
		0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x00, 0x01,
		0x61, 0xc0, 0x00,
	}
	_, _, err := ParseLabels(255, payload)
	if !errors.Is(err, ErrDecodeDnsLabelTooLong) {
		t.Errorf("bad error returned: %v", err)
	}
}

func TestDecodeDnsLabel_InvalidPtr_SimpleLoop(t *testing.T) {
	payload := []byte{0x01, 0x61, 0xc0, 0x00}

	_, _, err := ParseLabels(0, payload)
	if !errors.Is(err, ErrDecodeDnsLabelInvalidPointer) {
		t.Errorf("bad error returned: %v", err)
	}
}

func TestDecodeDnsLabel_InvalidPtr_Forwards(t *testing.T) {
	payload := []byte{0xc0, 0x02, 0x00}

	_, _, err := ParseLabels(0, payload)
	if !errors.Is(err, ErrDecodeDnsLabelInvalidPointer) {
		t.Errorf("bad error returned: %v", err)
	}
}

func TestDecodeDnsLabel_InvalidPtr_BackwardsInsideCurrentLabel1(t *testing.T) {
	payload := []byte{0x01, 0x02, 0xc0, 0x01, 0x00}

	_, _, err := ParseLabels(0, payload)
	if !errors.Is(err, ErrDecodeDnsLabelInvalidPointer) {
		t.Errorf("bad error returned: %v", err)
	}
}

func TestDecodeDnsLabel_InvalidPtr_BackwardsOverlappingLoop(t *testing.T) {
	payload := []byte{0x01, 0x61, 0x01, 0x61, 0xc0, 0x00}

	_, _, err := ParseLabels(2, payload)
	if !errors.Is(err, ErrDecodeDnsLabelInvalidPointer) {
		t.Errorf("bad error returned: %v", err)
	}
}

func TestDecodeDnsLabel_InvalidPtr_BackwardsOverlappingTerminating(t *testing.T) {
	payload := []byte{0x01, 0x01, 0x00, 0xc0, 0x00}

	_, _, err := ParseLabels(1, payload)
	if !errors.Is(err, ErrDecodeDnsLabelInvalidPointer) {
		t.Errorf("bad error returned: %v", err)
	}
}

func TestDecodeDnsLabel_InvalidPtr_BackwardsOverlappingPtr(t *testing.T) {
	// The second pointer byte overlaps the beginning of the label that starts at payload[3]
	payload := []byte{0x00, 0x00, 0xc0, 0x01, 0x00, 0xc0, 0x02}

	_, _, err := ParseLabels(3, payload)
	if !errors.Is(err, ErrDecodeDnsLabelInvalidPointer) {
		t.Errorf("bad error returned: %v", err)
	}
}

func TestDecodeDnsLabel_EndOffset_WithoutPtr(t *testing.T) {
	payload := []byte{0x02, 0x61, 0x61, 0x00}

	_, offset, _ := ParseLabels(0, payload)
	if offset != 4 {
		t.Errorf("invalid end offset: %v", offset)
	}
}

func TestDecodeDnsLabel_EndOffset_WithPtr(t *testing.T) {
	payload := []byte{0x01, 0x61, 0x00, 0x02, 0x61, 0x61, 0xc0, 0x00}

	_, offset, _ := ParseLabels(3, payload)
	if offset != 8 {
		t.Errorf("invalid end offset: %v", offset)
	}
}

func TestDecodePayload_QueryHappy(t *testing.T) {
	payload := []byte{
		//header
		0x9e, 0x84, 0x01, 0x20, 0x00, 0x01, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x01,
		// query section
		// name
		0x0b, 0x73, 0x65, 0x6e,
		0x73, 0x6f, 0x72, 0x66, 0x6c, 0x65, 0x65, 0x74,
		0x03, 0x63, 0x6f, 0x6d, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// Additional records: EDNS OPT with no data, DO = 0, Z=0
		0x00, 0x00, 0x29, 0x10, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00,
	}

	dm := DnsMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDns(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, GetFakeConfig()); err != nil {
		t.Errorf("Unexpected error while decoding payload: %v", err)
	}
	if dm.DNS.MalformedPacket != false {
		t.Errorf("did not expect packet to be malformed")
	}

	if dm.DNS.Id != 0x9e84 ||
		dm.DNS.Opcode != 0 ||
		dm.DNS.Rcode != RcodeToString(0) ||
		dm.DNS.Flags.QR ||
		dm.DNS.Flags.TC ||
		dm.DNS.Flags.AA ||
		!dm.DNS.Flags.AD ||
		dm.DNS.Flags.RA {
		t.Error("Invalid DNS header data in message")
	}

	if dm.DNS.Qname != "sensorfleet.com" {
		t.Errorf("Unexpected query name: %s", dm.DNS.Qname)
	}
	if dm.DNS.Qtype != "A" {
		t.Errorf("Unexpected query type: %s", dm.DNS.Qtype)
	}

	if dm.EDNS.Do != 1 ||
		dm.EDNS.UdpSize != 4096 ||
		dm.EDNS.Z != 0 ||
		dm.EDNS.Version != 0 ||
		len(dm.EDNS.Options) != 0 {
		t.Errorf("Unexpected EDNS data")
	}

	if len(dm.DNS.DnsRRs.Answers) != 0 ||
		len(dm.DNS.DnsRRs.Nameservers) != 0 ||
		len(dm.DNS.DnsRRs.Records) != 0 {
		t.Errorf("Unexpected sections parsed")
	}

}
func TestDecodePayload_QueryInvalid(t *testing.T) {
	payload := []byte{
		//header
		0x9e, 0x84, 0x01, 0x20, 0x00, 0x01, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x01,
		// query section
		// name
		0x0b, 0x73, 0x65, 0x6e,
		0x73, 0x6f, 0x72, 0x66, 0x6c, 0x65, 0x65, 0x74,
		0x83, 0x63, 0x6f, 0x6d, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// Additional records: EDNS OPT with no data, DO = 1, Z=0
		0x00, 0x00, 0x29, 0x10, 0x00, 0x00, 0x00,
		0x80, 0x00, 0x00, 0x00,
	}

	dm := DnsMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDns(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, GetFakeConfig()); err == nil {
		t.Errorf("Expected error when parsing payload")
	}
	if dm.DNS.MalformedPacket != true {
		t.Errorf("expected packet to be marked as malformed")
	}

	// returned error should wrap the original error
	if !errors.Is(err, ErrDecodeDnsLabelInvalidData) {
		t.Errorf("bad error returned: %v", err)
	}
}

func TestDecodePayload_AnswerHappy(t *testing.T) {
	payload := []byte{
		0x9e, 0x84, 0x81, 0x80, 0x00, 0x01, 0x00, 0x04,
		0x00, 0x00, 0x00, 0x01,
		// Query section
		0x0b, 0x73, 0x65, 0x6e,
		0x73, 0x6f, 0x72, 0x66, 0x6c, 0x65, 0x65, 0x74,
		0x03, 0x63, 0x6f, 0x6d, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// Answer 1
		0xc0, 0x0c, // pointer to name
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.1
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x01,
		// Answer 2
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.2
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x02,
		// Answer 3
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.3
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x03,
		// Answer 4
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.4
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x04,
		// Additianl records, EDNS Option, 0 bytes DO=0, Z = 0
		0x00, 0x00, 0x29, 0x04, 0xd0, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
	}

	dm := DnsMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDns(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, GetFakeConfig()); err != nil {
		t.Errorf("Unexpected error while decoding payload: %v", err)
	}
	if dm.DNS.MalformedPacket != false {
		t.Errorf("did not expect packet to be malformed")
	}

	if dm.DNS.Id != 0x9e84 ||
		dm.DNS.Opcode != 0 ||
		dm.DNS.Rcode != RcodeToString(0) ||
		!dm.DNS.Flags.QR ||
		dm.DNS.Flags.TC ||
		dm.DNS.Flags.AA ||
		dm.DNS.Flags.AD ||
		!dm.DNS.Flags.RA {
		t.Error("Invalid DNS header data in message")
	}

	if dm.DNS.Qname != "sensorfleet.com" {
		t.Errorf("Unexpected query name: %s", dm.DNS.Qname)
	}
	if dm.DNS.Qtype != "A" {
		t.Errorf("Unexpected query type: %s", dm.DNS.Qtype)
	}

	if len(dm.DNS.DnsRRs.Answers) != 4 {
		t.Errorf("expected 4 answers, got %d", len(dm.DNS.DnsRRs.Answers))
	}

	for i, ans := range dm.DNS.DnsRRs.Answers {
		expected := DnsAnswer{
			Name:      dm.DNS.Qname,
			Rdatatype: RdatatypeToString(0x0001),
			Class:     0x0001,
			Ttl:       300,
			Rdata:     fmt.Sprintf("10.10.1.%d", i+1),
		}
		if expected != ans {
			t.Errorf("unexpected answer (%d). expected %v, got %v", i, expected, ans)
		}
	}

	if dm.EDNS.Do != 0 ||
		dm.EDNS.UdpSize != 1232 ||
		dm.EDNS.Z != 0 ||
		dm.EDNS.Version != 0 ||
		len(dm.EDNS.Options) != 0 {
		t.Errorf("Unexpected EDNS data")
	}

	if len(dm.DNS.DnsRRs.Nameservers) != 0 ||
		len(dm.DNS.DnsRRs.Records) != 0 {
		t.Errorf("Unexpected sections parsed")
	}

}

func TestDecodePayload_AnswerMultipleQueries(t *testing.T) {
	payload := []byte{
		0x9e, 0x84, 0x81, 0x80, 0x00, 0x02, 0x00, 0x04,
		0x00, 0x00, 0x00, 0x01,
		// Query section
		// query 1
		0x0b, 0x73, 0x65, 0x6e,
		0x73, 0x6f, 0x72, 0x66, 0x6c, 0x65, 0x65, 0x74,
		0x03, 0x63, 0x6f, 0x6d, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// query 2
		0x0a, 0x65, 0x6e,
		0x73, 0x6f, 0x72, 0x66, 0x6c, 0x65, 0x65, 0x74,
		0x03, 0x63, 0x6f, 0x6d, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,

		// Answer 1
		0xc0, 0x0c, // pointer to name
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.1
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x01,
		// Answer 2
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.2
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x02,
		// Answer 3
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.3
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x03,
		// Answer 4
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.4
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x04,
		// Additianl records, EDNS Option, 0 bytes DO=0, Z = 0
		0x00, 0x00, 0x29, 0x04, 0xd0, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
	}

	dm := DnsMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDns(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, GetFakeConfig()); err != nil {
		t.Errorf("Unexpected error while decoding payload: %v", err)
	}
	if dm.DNS.MalformedPacket != false {
		t.Errorf("did not expect packet to be malformed")
	}

	if dm.DNS.Id != 0x9e84 ||
		dm.DNS.Opcode != 0 ||
		dm.DNS.Rcode != RcodeToString(0) ||
		!dm.DNS.Flags.QR ||
		dm.DNS.Flags.TC ||
		dm.DNS.Flags.AA ||
		dm.DNS.Flags.AD ||
		!dm.DNS.Flags.RA {
		t.Error("Invalid DNS header data in message")
	}

	if dm.DNS.Qname != "ensorfleet.com" {
		t.Errorf("Unexpected query name: %s", dm.DNS.Qname)
	}
	if dm.DNS.Qtype != "A" {
		t.Errorf("Unexpected query type: %s", dm.DNS.Qtype)
	}

	if len(dm.DNS.DnsRRs.Answers) != 4 {
		t.Errorf("expected 4 answers, got %d", len(dm.DNS.DnsRRs.Answers))
	}

	for i, ans := range dm.DNS.DnsRRs.Answers {
		expected := DnsAnswer{
			Name:      "s" + dm.DNS.Qname, // answers have qname from 1st query data, 2nd data is missing 's'
			Rdatatype: RdatatypeToString(0x0001),
			Class:     0x0001,
			Ttl:       300,
			Rdata:     fmt.Sprintf("10.10.1.%d", i+1),
		}
		if expected != ans {
			t.Errorf("unexpected answer (%d). expected %v, got %v", i, expected, ans)
		}
	}

	if dm.EDNS.Do != 0 ||
		dm.EDNS.UdpSize != 1232 ||
		dm.EDNS.Z != 0 ||
		dm.EDNS.Version != 0 ||
		len(dm.EDNS.Options) != 0 {
		t.Errorf("Unexpected EDNS data")
	}

	if len(dm.DNS.DnsRRs.Nameservers) != 0 ||
		len(dm.DNS.DnsRRs.Records) != 0 {
		t.Errorf("Unexpected sections parsed")
	}

}

func TestDecodePayload_AnswerInvalid(t *testing.T) {
	payload := []byte{
		0x9e, 0x84, 0x81, 0x80, 0x00, 0x01, 0x00, 0x04,
		0x00, 0x00, 0x00, 0x01,
		// Query section
		0x0b, 0x73, 0x65, 0x6e,
		0x73, 0x6f, 0x72, 0x66, 0x6c, 0x65, 0x65, 0x74,
		0x03, 0x63, 0x6f, 0x6d, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// Answer 1
		0xc0, 0x0c, // pointer to name
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.1
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x01,
		// Answer 2
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.2
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x02,
		// Answer 3
		0xc0, 0xff,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.3
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x03,
		// Answer 4
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.4
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x04,
		// Additianl records, EDNS Option, 0 bytes DO=0, Z = 0
		0x00, 0x00, 0x29, 0x04, 0xd0, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
	}

	dm := DnsMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDns(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, GetFakeConfig()); err == nil {
		t.Error("expected decoding to fail")
	}
	// returned error should wrap the original error
	if !errors.Is(err, ErrDecodeDnsLabelInvalidPointer) {
		t.Errorf("bad error returned: %v", err)
	}
	if dm.DNS.MalformedPacket != true {
		t.Errorf("expected packet to be malformed")
	}
}

func TestDecodePayload_AnswerInvalidQuery(t *testing.T) {
	payload := []byte{
		0x9e, 0x84, 0x81, 0x80, 0x00, 0x01, 0x00, 0x04,
		0x00, 0x00, 0x00, 0x01,
		// Query section
		0x0b, 0x73, 0x65, 0x6e,
		0x73, 0x6f, 0x72, 0x66, 0x6c, 0x65, 0x65, 0x74,
		0x83, 0x63, 0x6f, 0x6d, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// Answer 1
		0xc0, 0x0c, // pointer to name
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.1
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x01,
		// Answer 2
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.2
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x02,
		// Answer 3
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.3
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x03,
		// Answer 4
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.4
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x04,
		// Additianl records, EDNS Option, 0 bytes DO=0, Z = 0
		0x00, 0x00, 0x29, 0x04, 0xd0, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
	}

	dm := DnsMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDns(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, GetFakeConfig()); err == nil {
		t.Error("expected decoding to fail")
	}
	// returned error should wrap the original error
	if !errors.Is(err, ErrDecodeDnsLabelInvalidData) {
		t.Errorf("bad error returned: %v", err)
	}
	if dm.DNS.MalformedPacket != true {
		t.Errorf("expected packet to be malformed")
	}

	// after error has been detected in the query part, we should not parse
	// anything from answers
	if len(dm.DNS.DnsRRs.Answers) != 0 {
		t.Errorf("did not expect answers to be parsed, but there were %d parsed", len(dm.DNS.DnsRRs.Answers))
	}
}

func TestDecodePayload_AnswerInvalidEdns(t *testing.T) {
	payload := []byte{
		0x9e, 0x84, 0x81, 0x80, 0x00, 0x01, 0x00, 0x04,
		0x00, 0x00, 0x00, 0x01,
		// Query section
		0x0b, 0x73, 0x65, 0x6e,
		0x73, 0x6f, 0x72, 0x66, 0x6c, 0x65, 0x65, 0x74,
		0x03, 0x63, 0x6f, 0x6d, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// Answer 1
		0xc0, 0x0c, // pointer to name
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.1
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x01,
		// Answer 2
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.2
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x02,
		// Answer 3
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.3
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x03,
		// Answer 4
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.4
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x04,
		// Additianl records, Invalid EDNS Option
		0x00, 0x00, 0x29, 0x04, 0xd0, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x01,
	}

	dm := DnsMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDns(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, GetFakeConfig()); err == nil {
		t.Error("expected decoding to fail")
	}
	// returned error should wrap the original error
	if !errors.Is(err, ErrDecodeEdnsOptionTooShort) {
		t.Errorf("bad error returned: %v", err)
	}
	if dm.DNS.MalformedPacket != true {
		t.Errorf("expected packet to be malformed")
	}
}

func TestDecodePayload_AnswerInvaliAdditional(t *testing.T) {
	payload := []byte{
		0x9e, 0x84, 0x81, 0x80, 0x00, 0x01, 0x00, 0x04,
		0x00, 0x00, 0x00, 0x01,
		// Query section
		0x0b, 0x73, 0x65, 0x6e,
		0x73, 0x6f, 0x72, 0x66, 0x6c, 0x65, 0x65, 0x74,
		0x03, 0x63, 0x6f, 0x6d, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// Answer 1
		0xc0, 0x0c, // pointer to name
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.1
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x01,
		// Answer 2
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.2
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x02,
		// Answer 3
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.3
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x03,
		// Answer 4
		0xc0, 0x0c,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x01, 0x2c,
		// 10.10.1.4
		0x00, 0x04, 0x0a, 0x0a, 0x01, 0x04,
		// Additianl records, Invalid RDLENGTH
		0x00, 0x00, 0x29, 0x04, 0xd0, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x01,
	}

	dm := DnsMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDns(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, GetFakeConfig()); err == nil {
		t.Error("expected decoding to fail")
	}
	// returned error should wrap the original error
	if !errors.Is(err, ErrDecodeDnsAnswerRdataTooShort) {
		t.Errorf("bad error returned: %v", err)
	}
	if dm.DNS.MalformedPacket != true {
		t.Errorf("expected packet to be malformed")
	}
}

func TestDecodePayload_AnswerError(t *testing.T) {
	payload := []byte{
		// header
		0xa8, 0x1a, 0x81, 0x83, 0x00, 0x01, 0x00, 0x00,
		0x00, 0x01, 0x00, 0x01,
		// query
		0x03, 0x66, 0x6f, 0x6f,
		0x06, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x03,
		0x63, 0x6f, 0x6d, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// Authority section
		// name
		0xc0, 0x10,
		// type SOA, class IN
		0x00, 0x06, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x00, 0x3c,
		// RDLENGTH
		0x00, 0x26,
		// RDATA
		// MNAME
		0x03, 0x6e, 0x73, 0x31,
		0xc0, 0x10,
		// RNAME
		0x09, 0x64, 0x6e, 0x73, 0x2d, 0x61,
		0x64, 0x6d, 0x69, 0x6e, 0xc0, 0x10,
		// serial
		0x19, 0xa1, 0x4a, 0xb4,
		// refresh
		0x00, 0x00, 0x03, 0x84,
		// retry
		0x00, 0x00, 0x03, 0x84,
		// expire
		0x00, 0x00, 0x07, 0x08,
		// minimum
		0x00, 0x00, 0x00, 0x3c,
		// Additianl records, EDNS Option, 0 bytes DO=1, Z = 0
		0x00, 0x00, 0x29, 0x04, 0xd0, 0x00,
		0x00, 0x80, 0x00, 0x00, 0x00,
	}
	dm := DnsMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDns(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, GetFakeConfig()); err != nil {
		t.Errorf("Unexpected error while decoding payload: %v", err)
	}
	if dm.DNS.MalformedPacket != false {
		t.Errorf("did not expect packet to be malformed")
	}

	if dm.DNS.Id != 0xa81a ||
		dm.DNS.Opcode != 0 ||
		dm.DNS.Rcode != RcodeToString(3) ||
		!dm.DNS.Flags.QR ||
		dm.DNS.Flags.TC ||
		dm.DNS.Flags.AA ||
		dm.DNS.Flags.AD ||
		!dm.DNS.Flags.RA {
		t.Error("Invalid DNS header data in message")
	}

	if dm.DNS.Qname != "foo.google.com" {
		t.Errorf("Unexpected query name: %s", dm.DNS.Qname)
	}
	if dm.DNS.Qtype != "A" {
		t.Errorf("Unexpected query type: %s", dm.DNS.Qtype)
	}

	if len(dm.DNS.DnsRRs.Answers) != 0 {
		t.Errorf("did not expect any answers, got %d", len(dm.DNS.DnsRRs.Answers))
	}

	if len(dm.DNS.DnsRRs.Nameservers) != 1 {
		t.Errorf("expected 1 authority RR, got %d", len(dm.DNS.DnsRRs.Nameservers))
	}
	expected := DnsAnswer{
		Name:      "google.com",
		Rdatatype: RdatatypeToString(0x0006),
		Class:     0x0001,
		Ttl:       60,
		Rdata:     "ns1.google.com dns-admin.google.com 430000820 900 900 1800 60",
	}

	if dm.DNS.DnsRRs.Nameservers[0] != expected {
		t.Errorf("unexpected SOA record parsed, expected %v, git %v", expected, dm.DNS.DnsRRs.Nameservers[0])
	}

	if dm.EDNS.Do != 1 ||
		dm.EDNS.UdpSize != 1232 ||
		dm.EDNS.Z != 0 ||
		dm.EDNS.Version != 0 ||
		len(dm.EDNS.Options) != 0 {
		t.Errorf("Unexpected EDNS data")
	}

}

func TestDecodePayload_AnswerError_Invalid(t *testing.T) {
	payload := []byte{
		// header
		0xa8, 0x1a, 0x81, 0x83, 0x00, 0x01, 0x00, 0x00,
		0x00, 0x01, 0x00, 0x01,
		// query
		0x03, 0x66, 0x6f, 0x6f,
		0x06, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x03,
		0x63, 0x6f, 0x6d, 0x00,
		// type A, class IN
		0x00, 0x01, 0x00, 0x01,
		// Authority section
		// name
		0xc0, 0x10,
		// type SOA, class IN
		0x00, 0x06, 0x00, 0x01,
		// TTL
		0x00, 0x00, 0x00, 0x3c,
		// RDLENGTH
		0x00, 0x26,
		// RDATA
		// MNAME, invalid offset in pointer
		0x03, 0x6e, 0x73, 0x31,
		0xc0, 0xff,
		// RNAME
		0x09, 0x64, 0x6e, 0x73, 0x2d, 0x61,
		0x64, 0x6d, 0x69, 0x6e, 0xc0, 0x10,
		// serial
		0x19, 0xa1, 0x4a, 0xb4,
		// refresh
		0x00, 0x00, 0x03, 0x84,
		// retry
		0x00, 0x00, 0x03, 0x84,
		// expire
		0x00, 0x00, 0x07, 0x08,
		// minimum
		0x00, 0x00, 0x00, 0x3c,
		// Additianl records, EDNS Option, 0 bytes DO=1, Z = 0
		0x00, 0x00, 0x29, 0x04, 0xd0, 0x00,
		0x00, 0x80, 0x00, 0x00, 0x00,
	}
	dm := DnsMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDns(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, GetFakeConfig()); err == nil {
		t.Error("expected decoding to fail")
	}
	// returned error should wrap the original error
	if !errors.Is(err, ErrDecodeDnsLabelInvalidPointer) {
		t.Errorf("bad error returned: %v", err)
	}
	if dm.DNS.MalformedPacket != true {
		t.Errorf("expected packet to be malformed")
	}

}

func TestDecodePayload_AdditionalRRAndEDNS(t *testing.T) {
	// payload containing both addition RR and EDNS, ensure we are
	// able to parse all of them
	payload := []byte{
		0x7b, 0x97, 0x84, 0x0, 0x0, 0x1, 0x0, 0x2,
		0x0, 0x2, 0x0, 0x5, 0xf, 0x6f, 0x63, 0x63,
		0x2d, 0x30, 0x2d, 0x31, 0x35, 0x30, 0x30,
		0x2d, 0x31, 0x35, 0x30, 0x31, 0x1, 0x31,
		0x6, 0x6e, 0x66, 0x6c, 0x78, 0x73, 0x6f,
		0x3, 0x6e, 0x65, 0x74, 0x0, 0x0, 0x1, 0x0,
		0x1, 0xc0, 0xc, 0x0, 0x1, 0x0, 0x1, 0x0,
		0x0, 0x0, 0x1e, 0x0, 0x4, 0x2d, 0x39, 0x24,
		0x97, 0xc0, 0xc, 0x0, 0x1, 0x0, 0x1, 0x0,
		0x0, 0x0, 0x1e, 0x0, 0x4, 0x2d, 0x39, 0x24,
		0x94, 0xc0, 0x1e, 0x0, 0x2, 0x0, 0x1, 0x0,
		0x1, 0x51, 0x80, 0x0, 0x7, 0x1, 0x65, 0x2,
		0x6e, 0x73, 0xc0, 0x1e, 0xc0, 0x1e, 0x0,
		0x2, 0x0, 0x1, 0x0, 0x1, 0x51, 0x80, 0x0,
		0x4, 0x1, 0x66, 0xc0, 0x5c, 0x0, 0x0, 0x29,
		0x4, 0xb0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc0,
		0x5a, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x51, 0x80,
		0x0, 0x4, 0x2d, 0x39, 0x8, 0x1, 0xc0, 0x5a,
		0x0, 0x1c, 0x0, 0x1, 0x0, 0x1, 0x51, 0x80, 0x0,
		0x10, 0x2a, 0x0, 0x86, 0xc0, 0x20, 0x8, 0x0, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0xc0, 0x6d,
		0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x51, 0x80, 0x0, 0x4,
		0x2d, 0x39, 0x9, 0x1, 0xc0, 0x6d, 0x0, 0x1c, 0x0, 0x1,
		0x0, 0x1, 0x51, 0x80, 0x0, 0x10, 0x2a, 0x0, 0x86, 0xc0,
		0x20, 0x9, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1}

	dm := DnsMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDns(payload)
	if err != nil {
		t.Errorf("error when deocoding header: %v", err)
	}

	if err := DecodePayload(&dm, &header, GetFakeConfig()); err != nil {
		t.Errorf("unexpected error while decoding payload: %v", err)
	}

	if len(dm.DNS.DnsRRs.Answers) != 2 || len(dm.DNS.DnsRRs.Nameservers) != 2 ||
		len(dm.DNS.DnsRRs.Records) != 4 || dm.EDNS.UdpSize != 1200 ||
		len(dm.EDNS.Options) != 0 {
		t.Errorf("unexpected result while parsing payload: %#v", dm.DNS)
	}

}

func TestDecodePayload_Truncated(t *testing.T) {
	payload := []byte{
		// header
		0x77, 0xa0, 0x83, 0x80, 0x00, 0x01, 0x00, 0x23,
		0x00, 0x00, 0x00, 0x00,
		// query
		0x02, 0x41, 0x64, 0x0d,
		0x6e, 0x6e, 0x6e, 0x6e,
		0x6e, 0x6e, 0x6e, 0x6e,
		0x6e, 0x6e, 0x6e, 0x6e,
		0x6e, 0x02, 0x46, 0x52,
		0x00, 0x00, 0x01, 0x00, 0x01,
		// answer 1
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x01,
		// answer 2
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x02,
		// answer 3
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x03,
		// answer 4
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x04,
		// answer 5
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x05,
		// answer 6
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x06,
		// answer 7
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x07,
		// answer 8
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x08,
		// answer 9
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x09,
		// answer 10
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x0a,
		// answer 11
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x0b,
		// answer 12
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x0c,
		// answer 13
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x0d,
		// answer 14
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x0e,
		// answer 15
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x0f,
		// answer 16
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x10,
		// answer 17
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x11,
		// answer 18
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x12,
		// answer 19
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x13,
		// answer 20
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x14,
		// answer 21
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x15,
		// answer 22
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x16,
		// answer 23
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x17,
		// answer 24
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x18,
		// answer 25
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x19,
		// answer 26
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x1a,
		// answer 27
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x1b,
		// answer 28
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x1c,
		// answer 29
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00, 0x04, 0x0a, 0x01,
		0x01, 0x1d,
		// answer 30
		0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x6b, 0x00,
	}

	dm := DnsMessage{}
	dm.DNS.Payload = payload
	dm.DNS.Length = len(payload)

	header, err := DecodeDns(payload)
	if err != nil {
		t.Errorf("unexpected error when decoding header: %v", err)
	}

	if err = DecodePayload(&dm, &header, GetFakeConfig()); err != nil {
		t.Error("expected no error on decode")
	}

	if dm.DNS.Flags.TC == false {
		t.Error("truncated answer expected")
	}

	if dm.DNS.MalformedPacket != true {
		t.Errorf("expected packet to be malformed")
	}

}
